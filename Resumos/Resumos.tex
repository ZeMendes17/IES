\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{geometry}
\usepackage{graphicx}
\graphicspath{ {./Images/} }
\usepackage[shortlabels]{enumitem}
\usepackage{fancyhdr}
\usepackage{ulem}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\renewcommand\maketitlehooka{\null\mbox{}\vfill} %para centralizar verticalmente
\renewcommand\maketitlehookd{\vfill\null}
\pagestyle{fancy}
\fancyhf{}
\rfoot{\thepage}
\lfoot{ \includegraphics[scale=0.01]{UA.jpg} José Mendes 107188 LEI}
\geometry{
  a4paper,
  headheight=4cm,
  top=5.5cm,
  bottom=4.5cm,
  footskip=4cm
}


\title{Introdução à Engenharia de Software}
\author{José Mendes 107188}
\date{2023/2024}

\begin{document}


\begin{titlepage}
    \maketitle
    \begin{center}
        \includegraphics[scale=0.4]{UA.png}
    \end{center}
    \thispagestyle{empty} %remove o count da pagina
\end{titlepage}

\pagebreak

\section{Maven}

\subsection{O que é o Maven?}

É uma \textbf{ferramenta de gestão de projetos}, que inclui:
\begin{itemize}
  \item Um \textbf{project object model} (POM) que descreve o projeto;
  \item Um conjunto de \textbf{standards};
  \item Um \textbf{lifecycle} do projeto;
  \item Um sistema de gestão de \textbf{dependências};
  \item Lógica para \textbf{executar plugins} em \textbf{fases} específicas
  do ciclo de vida.
\end{itemize}

Convenção sobre configuração (layout do projeto é padronizado).

\subsection{Layout de Diretórios Padronizado}

\begin{flushleft}
  \textbf{POM} - Contém uma descrição completa do projeto de como
  construir o projeto.

  \vspace{2mm}

  \textbf{src} - Diretório que contém todo o código fonte para construir
  o projeto, o seu site, \dots

  \vspace{2mm}

  \textbf{target} - Diretório que contém os resultados da construção,
  tipicamente um JAR ou WAR, juntamente com os ficheiros intermedios.
\end{flushleft}

\subsection{POM}

Maven é baseado no conceito de um \textbf{Project Object Model} (POM).
Este é um ficheiro XML, que está sempre localizado no diretório base do projeto
como \textbf{pom.xml} (os users definiram POMs que estendem o Super POM).

O POM contém informação sobre o projeto e vários detalhes de configuração
usados pelo Maven para construir o projeto.

O POM é declarativo, não necessita de detalhes de procedimento.

\subsubsection{Estrutura do POM}

\begin{flushleft}
  O POM contém 4 categorias de descrição e configuração:
  
  \begin{itemize}
    \item Informação geral do projeto, isto é, informação human-readable;
    \item Configuração do build, que pode incluir, adicionar plugins,
    afixar plugins objetivo ao ciclo de vida;
    \item Ambiente de construção, que descreve o ambiente "familiar" em que o Maven está;
    \item Relações POM, isto é, coordenadas, herança, agregação, dependências.
  \end{itemize}
\end{flushleft}

\pagebreak

\subsection{Coordenadas Maven}

As coordenadas definem o lugar único do projeto no universo Maven.
São compostas por 3 partes: \textbf{$<$groupId$>$}, \textbf{$<$artifactId$>$} e
\textbf{$<$version$>$} (The Maven trinity!).

\vspace{2mm}

As versões de um projeto são usadas para agrupar e ordenar lançamentos:

\[ <major\_version>.<minor\_version>.<incremental\_version>-<qualifier> \]

\begin{flushleft}
  \textbf{Exemplo:} 1.0.0-SNAPSHOT ou 1.2.3-alpha-2
\end{flushleft}

Se o qualifier contiver a palavra chave SNAPSHOT, então o Maven
vai expandir este token para uma data e hora convertida para o formato UTC.

\vspace{2mm}

\begin{flushleft}
  \begin{itemize}
    \item \textbf{groupId} - Nome da empresa, organização, equipa, \dots,
    normalmente usando a convenção de nomes de domínio invertidos (reverse URL naming, ex: org.apache.maven);

    \item \textbf{artifactId} - Nome único do projeto dentro do groupId;
    
    \item \textbf{version} - Versão do projeto;
    \item \textbf{packaging} - Tipo de empacotamento do projeto (jar (default), war, \dots);
    \item \textbf{classifier} - Classificador opcional para distinguir artefactos
  \end{itemize}

  \vspace{2mm}

  \textbf{Nota:} As coordenadas Maven identificam unicamente um projeto.
\end{flushleft}

\subsection{Ciclo de Vida Maven}

Um ciclo de vida é uma sequência organizada de fases,
que dão ordem a uma sequência de objetivos.
Estes objetivos são empacotados em plugins que estão ligados
as fases.

\begin{center}
  \includegraphics[scale=0.5]{1}
\end{center}

Chamar uma fase específica num ciclo de construção, vai executar
todas as fases anteriores a essa fase.

\pagebreak

\begin{center}
  \includegraphics[scale=0.5]{2}
\end{center}

\begin{flushleft}
  \begin{enumerate}
    \item \textbf{Validate} - Valida que a estrutura do projeto está correta.
    (ex: verifica se todas as dependências foram transferidas e estão disponíveis
    no repositório local);

    \item \textbf{Compile} - Compila o código fonte, converte os ficheiros
    \textbf{.java} em \textbf{.class}, e armazenando-os no diretório \textbf{target/classes};

    \item \textbf{Test} - Corre testes unitários para o projeto;
    \item \textbf{Package} - Empacota o código compilado num formato distribuível
    como \textbf{JAR} ou \textbf{WAR};

    \item \textbf{Integration Test} - Corre testes de integração para o projeto;
    \item \textbf{Verify} - Corre verificações para verificar que o projeto é válido
    e que cumpre os critérios de qualidade;

    \item \textbf{Install} - Instala o código empacotado
    no repositório Maven local, para uso como dependência noutros projetos locais;

    \item \textbf{Deploy} - Copia o pacote final de código para o repositório
    remoto para partilha com outros developers e projetos.
  \end{enumerate}
\end{flushleft}

\subsection{Ciclo de Vida de Construção}

O processo para contruir e distribuir um projeto. Consiste
em vários passos designados por \textbf{fases}.

Algumas fases default são:
\begin{itemize}
  \item \textbf{validate}
  \item \textbf{compile}
  \item \textbf{test}
  \item \textbf{package}
  \item \textbf{deploy}
\end{itemize}

\pagebreak

\subsection{Goals e Plugins}

Os Goals são operações fornecidas pelas ferramentas Maven.

Cada fase é uma sequência de Goals, em que cada Goal é responsável
por uma tarefa específica. Quando corremos uma fase, todos os Goals
ligados a essa fase são executados, na ordem em que estão definidos.

\begin{flushleft}
  Algumas Maven Plugins:
  \begin{itemize}
    \item resources
    \item compiler
    \item surefire
    \item jar, war
  \end{itemize}
\end{flushleft}

\subsection{Arquétipos (Archetypes)}

Um Archetype é um template para um projeto Maven, que pode ser usado para
criar um novo projeto rapidamente.

\begin{flushleft}
  \textbf{Exemplo:} \textit{maven-archetype-quickstart} ou \textit{maven-archetype-webapp}
\end{flushleft}

Users podem criar os seus próprios Archetypes e publicá-los através de catálogos.

\subsection{Gestor de Dependências}

Uma \textbf{dependência} de um projeto é uma biblioteca da qual
o projeto depende. Adicionar uma dependência ao projeto é simples,
basta adicionar a dependência ao POM. O Maven vai automaticamente
procurar a dependência no repositório local, e se não encontrar,
vai procurar no repositório remoto e transferi-la.

\begin{center}
  \includegraphics[scale=0.6]{3}
\end{center}

\pagebreak

\section{Git e GitHub}

\subsection{Sistemas de Controlo de Versões}

Um sistema de controlo de versões (também conhecido como sistema de controlo de código fonte) faz o seguinte:
\begin{itemize}
  \item Mantém várias (antigas e novas) versões de tudo (não só código fonte);
  \item Pede por comentários quando se fazem alterações;
  \item Permite "check-in" e "check-out" de ficheiros para saber
  em que ficheiros outras pessoas estão a trabalhar;
  \item Mostra as diferenças entre versões;
\end{itemize}

\subsubsection{Vantagens}

\begin{flushleft}
  \textbf{Ao trabalhar sozinho:} Fornece uma "máquina do tempo" para
  voltar atrás para uma versão anterior, e fornece um bom suporte 
  de diferentes versões do mesmo projeto.

  \vspace{2mm}

  \textbf{Ao trabalhar em equipa:} Simplifica muito trabalhar em concurrencia,
  dando "merge" de alterações feitas por diferentes pessoas.
\end{flushleft}

\subsection{o que é Git e GitHub}

\begin{center}
  \includegraphics[scale=0.5]{4}
\end{center}

Quando fazemos "git init" num diretório de um projeto, ou quando fazemos
"git clone" de um projeto existente, o Git cria um repositório (.git).

Em qualquer momento, podemos fazer um "snapshot" de tudo
no dirétorio do projeto e guardar este no repositório.
Este "snapshot" é chamado de \textbf{commit object}.

\pagebreak

Um \textbf{commit} ocorre quando fazemos alterações que estão
prontas para serem guardadas no repositório.

Quando realizamos um commit, o Git guarda um \textbf{commit object}:
\begin{itemize}
  \item Um estado completo do projeto, incluindo todos os ficheiros;
  \item O primeio não possui pai;
  \item Normalmente, pegamos num commit object, fazemos alterações,
  e criamos um novo commit object, pelo que a maior parte dos commit objects
  têm apenas um pai;
  \item Quando fazemos \textbf{merge} de dois commit objects,
  forma um commit object com dois pais.
\end{itemize}

Pelo que, os commit objects formam uma \textbf{DAG} (Directed Acyclic Graph).
O Git é tudo sobre usar e manipular este grafo.

\subsubsection{Mensagem de Commit}

Os commits são "baratos" pelo que os devemos fazer com frequência, e com
mensagens descritivas sobre o que foi alterado. Devem ter apenas uma linha.

Como não devemos dizer muito numa linha, devemos fazer vários commits.

\begin{center}
  \includegraphics[scale=0.6]{5}
\end{center}

\subsection{Manter simples}

\begin{center}
  \includegraphics[scale=0.6]{6}
  \includegraphics[scale=0.6]{7}
\end{center}

\pagebreak

\section{O Processo de Desenvolvimento de Software}

\subsection{Processo}

A fundação para a Engenharia de Software é a camada de processo.
Um processo de Software é uma framework para as atividades,
ações, e tarefas necessárias para construir software de alta qualidade.
Define as técnicas e a framework de gestão para aplicação de métodos,
ferramentas e pessoas ao longo do processo de desenvolvimento.

\begin{center}
  \includegraphics[scale=0.6]{8}
\end{center}

\subsection{Porquê o Processo de Software?}

\begin{center}
  \includegraphics[scale=0.6]{9}
\end{center}

\subsection{Processo de Software}

Existem vários tipos de processos de software, no entanto, todos têm:

\begin{itemize}
  \item \textbf{Especificação (comunicação e planeamento)} - definir o que o sistema deve fazer;
  \item \textbf{Design e Implementação} - definir a organização do sistema e implementar o sistema;
  \item \textbf{Validação} - verificar que faz aquilo que o cliente quer;
  \item \textbf{Evolução} - alterar o sistema em resposta a novos requisitos impostos pelo cliente.
\end{itemize}


Quando discutimos sobre o processo de software, estamos a falar sobre:
\begin{itemize}
  \item \textbf{Atividades} - como especificar um modelo de dados, design de uma
  interface de utilizador, \dots;
  \item \textbf{Ordem} a ordem destas atividades;
\end{itemize}

A descrição de processos pode também incluir, \textbf{produtos} (outcome da
atividade do processo), \textbf{papéis} (roles, responsabilidades das pessoas envolvidas)
e \textbf{pré-/pós-condições} (são condições que são verdadeiras antes
e depois de atividade do processo ou de um produto ser produzido).

\pagebreak

O processo de software específica:
\begin{itemize}
  \item \textbf{O quê}
  \item \textbf{Quem}
  \item \textbf{Quando}
  \item \textbf{Como}
\end{itemize}

E incluí
\begin{itemize}
  \item \textbf{Papéis} (Roles)
  \item \textbf{Fluxo de trabalho} (Workflow)
  \item \textbf{Procedimentos} (Procedures)
  \item \textbf{Normas} (Standards)
  \item \textbf{Modelos} (Templates)
\end{itemize}

\subsection{Pontos Chave}

\textbf{\uline{O processo de Software é um guia}}

\vspace{2mm}

Não existe "um melhor processo para escrever software".
Um processo que um individuo ou uma organização escolhe e segue depende de:
\begin{itemize}
  \item das características específicas do projeto;
  \item da cultura da organização;
  \item das habilidades e preferências das pessoas envolvidas.
\end{itemize}

\vspace{2mm}

Um bom processo aumenta a produtividade de membros da equipa
menos experientes sem impedir o trabalho/progresso de membros
mais experientes.

\subsection{Resistência ao Processo de Software}

\begin{flushleft}
  \textbf{Perceção:} Algumas pessoas vêm seguir um processo como
  uma sobrecarga (overhead) desnecessária na produtividade.
  \begin{itemize}
    \item Interfere com a criatividade;
    \item Burocracia e regimento;
    \item Prejudica a agilidade em mercados que evoluem rapidamente.
  \end{itemize}

  \vspace{2mm}

  \textbf{A realidade:} Grupos que não seguem um processo definido
  tendem a adicionar processo mais tarde no projeto, como reação
  a problemas que surgem. Quando o tamanho e a complexidade do projeto
  aumenta, a importância de seguir processos definidos aumenta proporcionalmente. 
\end{flushleft}

\pagebreak

\subsection{Fases de Software}

\begin{center}
  \includegraphics[scale=0.6]{10}
\end{center}

\subsection{\uline{Modelos} de Processo de Software}

Modelos abstratos que descrevem uma classe abordagens de desenvolvimento
com características similares.

\vspace{2mm}

Alguns critérios utilizados para distinguir modelos de processos
de software são:
\begin{itemize}
  \item o tempo entre fases (timing);
  \item critérios de entrada e saída entre fases (entry/exit criteria);
  \item os artefactos criados durante cada fase;
\end{itemize}

\vspace{2mm}

Alguns \textbf{exemplos} incluem: Waterfall, Spiral, Rapid Prototyping,
Incremental, Development, \dots

\subsubsection{Modelos (Tradicionais)}

\begin{flushleft}
  \textbf{Modelo em Cascata (Waterfall):} É um modelo \uline{Plan-Driven}.
  Separa e distingue fases de especificação e desenvolvimento.

  \vspace{2mm}

  \textbf{Desenvolvimento Incremental:} A especificação, desenvolvimento
  e validação são intercalados. Pode ser \uline{Plan-Driven} ou \uline{Agile}.

  \vspace{2mm}

  \textbf{Processos Evolucionários/Iterativos:} O sistema é desenvolvido
  no ínicio usando uma especificação muito simples, sendo modificada
  e melhorada de acordo com as necessidades de software.

  \vspace{2mm}

  \textbf{Muitos outros:} A maior parte de sistemas grandes são desenvolvidos
  usando um processo que incorpora elementos de diferentes modelos.
\end{flushleft}

\pagebreak

\subsubsection{O Modelo em Cascata (Waterfall)}

\begin{center}
  \includegraphics[scale=0.6]{11}
\end{center}

\subsubsection*{Vantagens}

\begin{itemize}
  \item É simples e fácil de perceber e usar;
  \item É fácil de planear, um schedule pode ser definido
  com deadlines para cada fase de desenvolvido e um produto pode ser
  processado através do processo de desenvolvimento como um carro
  numa lavagem automática, e ,teoricamente, ser entregue a tempo.
  \item Fácil de gerir, cada fase tem entregas específicas e um
  processo de revisão.
  \item Fases e processos são concluídos um de cada vez.
  \item Funciona bem onde os requisitos são bem compreendidos.
\end{itemize}

\subsubsection*{Desvantagens}

\begin{itemize}
  \item Dificuldade em acomodar mudanças após o processo começar.
  Em principio, uma fase deve ser concluída antes de começar a próxima.
  Particionamento inflexível do projeto em fases distintas torna difícil
  responder a mudanças nos requisitos do cliente.
  \item Modelo não muito bom para projetos de longa duração ou que já estão em andamento
  (não é produzido nenhum software funcional até mais tarde no ciclo de vida).
  \item Não é adequado a processos onde os requisitos são incertos ou
  onde há risco de serem alterados.
\end{itemize}

\pagebreak

\subsubsection{Modelo Incremental}

Uma característica de modelos com ciclos de vida modernos.
O produto evolui através de uma série de iterações.

\begin{center}
  \includegraphics[scale=0.5]{12}
\end{center}

\subsubsection*{Benefícios}

\begin{itemize}
  \item O custo de \textbf{acomodar mudanças de requisitos do cliente} é reduzido.
  A quantidade de análise e documentação que tem de ser refeita é muito menor
  do que no modelo em cascata.

  \item É mais fácil \textbf{obter feedback do cliente} sobre o desenvolvimento
  do trabalho que já está concluído.
  Clientes podem comentar sobre demonstrações do software e ver
  quanto foi implementado.

  \item \textbf{Entrega mais rápida e deployment} do software útil
  para o cliente é possível. Os clientes podem usar e ganhar valor
  do software mais cedo do que se o sistema fosse desenvolvido
  com o processo em cascata.
\end{itemize}

\subsubsection*{Problemas}

\begin{itemize}
  \item \textbf{Cada fase de iteração é rigida} e não se sobrepoem
  umas com as outras.

  \item O processo não é visível. Os gestores precisam  de entragas regulares
  para medir o progresso. No entanto, se o sistema não for desenvolvido rapidamente,
  não é cost-effective produzir documentos que reflitam cada versão do sistema.

  \item A estrutura do sistema tende a degradar-se à medida que novos
  incrementos são adicionados. A não ser que tempo e dinheiro seja
  gasto na refatoração para melhorar o software,
  \textbf{regular mudanças tende a corromper a sua estrutura}.
  A medida que vamos incorporando novas mudanças de doftware,
  torna-se mais difícil e mais caro.
\end{itemize}

\pagebreak

\subsubsection{Modelos Evolucionários/Iterativos}

\begin{flushleft}
  \textbf{Prototipagem:} Geralmente, um cliente define um conjunto
  de objetivos gerais para o software, mas não identifica requisitos
  detalhados para funções e funcionalidades do sistema.

  \vspace{2mm}

  \textbf{Modelo Espiral:} Utilizando um modelo espiral, o software é desenvolvido
  numa serie de lançamentos (releases) evolutivos. Durante as primeiras iterações,
  o lançamento pode ser um protótipo ou um modelo.

  \vspace{2mm}

  \textbf{Modelo Concurrente:} Permite a uma equipa de software representar
  elementos iterativos e concurrentes de quaisquer modelos de processo.
\end{flushleft}

\subsubsection{Incremental vs Evolucionário/Iterativo}

\begin{center}
  \includegraphics[scale=0.5]{13}
\end{center}

\subsubsection{Exemplos}

\begin{center}
  \includegraphics[scale=0.32]{14}
  \includegraphics[scale=0.32]{15}
\end{center}

\pagebreak

\subsection{Outros Modelos de Processo}

\begin{itemize}
  \item Desenvolvimento \textbf{Component-Based} (COTS): O processo
  para aplicar quando reutilizar é um objetivo do desenvolvimento.

  \item \textbf{Métodos Formais}: Enfatiza a especificação matemática
  dos requisitos.

  \item \textbf{Processo Unificado (UP)}: Um processo de software
  "use-case driven, arquitetura-centric, iterativo e incremental",
  alinhado com o Unified Modeling Language (UML).
\end{itemize}

\subsection{Processo Unificado (UP)}

\begin{center}
  \includegraphics[scale=0.4]{16}
\end{center}

\subsubsection{Fases}

\begin{center}
  \includegraphics[scale=0.4]{17}
\end{center}

\pagebreak

\subsection{Processos Plan-Driven e Agile}

\textbf{Processos Plan-Driven} são processos onde todas as atividades
são planeadas \uline{anteciadamente} e o progresso é medido
contra este plano.

\vspace{2mm}

Em \textbf{Processos Agile}, planear é incremental e é mais fácil
mudar o processo para refletir a mudança nos requisitos do cliente.

\vspace{2mm}

Na prática, a maior parte dos processos incluem elementos de ambos,
processos plan-driven e agile. Não existem processos de software
"certos" ou "errados".

\subsubsection{Processos Plan-Driven vs Agile}

\begin{center}
  \includegraphics[scale=0.5]{18}
\end{center}

\subsubsection{Processos Agile}

Desenvolvimento rápido e entragas são, geralmente, os requisitos
mais importantes para sistemas de software.
\begin{itemize}
  \item Negócios operam num ambiente \textbf{fast-changing requirements}
  e é praticamente impossível produzir um conjunto de requisitos de software
  estáveis.
  \item O Software deve evoluir rapidamente para refletir mudanças de
  negócios.
\end{itemize}

\vspace{2mm}

Desenvolvimento Plan-Driven é essencialmente para alguns tipos de sistemas
mas não cobre as necessidades do negócio.

\subsubsection*{Métodos Agile}

\begin{itemize}
  \item Métodos Agile foram desenvolvidos num esforço para ultrapassar
  fraquezas percetidas e reais em engenharia de software convencional.
  
  \item \textbf{Foca no código em vez de no design}.
  
  \item Baseados em \textbf{abordagens iterativas} ao desenvolvimento
  de software.

  \item Tem a intenção de \textbf{entregar software funcional rapidamente}
  e evoluir rapidamente para refletir mudanças de requisitos do cliente.
\end{itemize}

\pagebreak

\subsubsection{Origem: Manifesto Agile}

"We are uncovering better ways of developing
software by doing it and helping others do it.
Through this work we have come to value:

\begin{itemize}
  \item \textbf{Individuals and interactions} over processes and tools
  \item \textbf{Working software} over comprehensive documentation
  \item \textbf{Customer collaboration} over contract negotiation
  \item \textbf{Responding to change} over following a plan
\end{itemize}

That is, while there is value in the items on the right,
we value the items on the left more."

\subsubsection{Princípios dos Métodos Agile}

\begin{flushleft}
  \textbf{Involvimento do cliente:} Os clientes devem estar envolvidos
  durante todo o porcesso de desenvolvimento. O seu papel é fornecer
  e priorizar novos requisitos e avaliar as iterações do sistema.
\end{flushleft}

\subsubsection{Desenvolvimento Plan-Driven e Agile}

\begin{center}
  \includegraphics[scale=0.4]{19}
\end{center}

\begin{flushleft}
  \textbf{Desenvolvimento Plan-Driven:}
  \begin{itemize}
    \item Baseado ao redor de um desenvolvimento separado de fases,
    com outputs a serem produzidos em cada fase planeada anteciadamente.
    \item Não é necessariamente o modelo em cascata - desenvolvimento
    incremental, plan-driven, é possível.
  \end{itemize}

  \vspace{2mm}

  \textbf{Desenvolvimento Agile:}
  \begin{itemize}
    \item Especificação, design, implementação e testes são intercalados.
    \item Os outputs do processo de desenvolvimento são decididos
    através de um processo de negociação durante o processo de desenvolvimento
    de software.
  \end{itemize}
\end{flushleft}

\pagebreak

\subsubsection{Métodos Agile - Benefícios}

\begin{itemize}
  \item Requisitos num modelo Agile podem ser alterados
  conforme os requisitos do cliente mudam. Por vezes os requisitos
  não são muito claros. Mudanças nos requisitos são aceites
  mesmo em fases avançadas do processo de desenvolvimento.

  \item A entrega de software é continua. Clientes podem seguir
  cada feature funcional do Sprint do software.

  \item Refatorar o código não é muito caro.
\end{itemize}

\subsubsection{Métodos Agile - Desvantagens}

\begin{itemize}
  \item A documentação é escassa.
  \item Com requisitos pouco claros, é difícil estimar o resultado pretendido.
  Mais díficil de estimar o esforço necessário.
  \item Alguns riscos desconhecidos/imprevisiveis que podem afetar o desenvolvimento do projeto. 
\end{itemize}

\subsubsection{Métodos Agile - Aplicabilidade}

\begin{itemize}
  \item Desenvolvimento de produtos, onde uma empresa de software está a desenvolver
  um produto pequeno/médio em tamanho para venda.

  \item Desenvolvimento de sistemas customizados dentro de uma organização,
  onde existe o compromisso do cliente ficar envolvido no processo de desenvolvimento
  e onde existem algumas regras/regulamentos externos que afetam o software.
  
  \item Virtualmente, todos os produtos de software e aplicações são desenvolvidas
  usando abordagens Agile.
\end{itemize}

\pagebreak

\section{Desenvolvimento de Software Agile}

\subsection{Princípios Agile}

\subsubsection{Porquê Agile?}

O desenvolvimento rápido e entrega são, geralmente, os requisitos
mais importantes para sistemas de software.
\begin{itemize}
  \item Negócios operam num ambiente \textbf{fast-changing requirements}
  e é praticamente impossível produzir um conjunto de requisitos de software
  estáveis.
  \item O Software deve evoluir rapidamente para refletir mudanças de
  negócios.
\end{itemize}

\vspace{2mm}

Princípios Agile:
\begin{itemize}
  \item \textbf{Focada no código em vez de no design};
  \item Baseados em \textbf{abordagens iterativas} ao desenvolvimento
  de software;
  \item Tem a intenção de \textbf{entregar software funcional rapidamente}
  e evoluir rapidamente para refletir mudanças de requisitos do cliente.
\end{itemize}

\begin{center}
  \includegraphics[scale=0.5]{20}
\end{center}

Ver analogia nos slides 6 a 15.

\pagebreak

\subsection{Técnicas de Desenvolvimento Agile}

As fases especificação, design, implementação e avaliação são intercaladas:
\begin{itemize}
  \item O sistema é desenvolvido  como uma série de versões, envolvendo
  \textbf{stakeholders} na especificaçãon e avaliação;
  \item Entregas de novas versões frequente para avaliação;
\end{itemize}

Vasto suporte de ferramentas (ex: ferramentas de testes automáticos) usado
para suportar o desenvolvimento.

\vspace{2mm}

Miníma documentação, uma vez que o foco é o código.

\begin{center}
  \includegraphics[scale=0.5]{21}
\end{center}

\subsubsection{Extreme Programming (XP)}

Extreme Programming (XP) é a abordagem mais utilizada para desenvolvimento
ágil de software. \textbf{Leva uma abordagem "extrema" para o desenvolvimento iterativo}:
\begin{itemize}
  \item Novas versões podem ser contruidas varias vezes por dia;
  \item Os incrementos são entregues aos clientes \uline{a cada 2 semanas};
  \item Todos os testes devem correr para cada build e cada buid apenas é aceite
  se todos os testes correrem com sucesso;
\end{itemize}

\vspace{2mm}

Utiliza uma abordagem orientada a objetos como o paradigma de desenvolvimento
preferido. Abrange um conjunto de regras e práticas que
ocorrem no contexto de quatro atividades fundamentais (framework activities):
\textbf{planning, design, coding, testing}.

\subsubsection{Release Cycle XP}

\begin{center}
  \includegraphics[scale=0.55]{22}
\end{center}

\pagebreak

\subsubsection{Práticas XP}

\begin{center}
  \includegraphics[scale=0.45]{23}
  \includegraphics[scale=0.45]{24}
\end{center}

\subsubsection{Práticas influentes de XP}

Extreme Programming tem um foco técnico e não é fácil de integrar
com prática de gestão na maior parte das organizações.
Consequentemente, enquanto desenvolvimento Agile utiliza práticas
de XP, o método referido não é muito utilizado.

\vspace{2mm}

Práticas Chave:
\begin{itemize}
  \item User stories para especificação;
  \item Refatoração;
  \item Desenvolvimento Test-First;
  \item Programação em pares (pair programming);
\end{itemize}

\subsubsection{User Stories para Requisitos}

Em XP, o cliente ou user são parte da equipa XP e são
\textbf{responsáveis por tomar decisões sobre requisitos}.

\vspace{2mm}

Requisitos do user são expressos como \textbf{user stories} ou
\textbf{scenarios}. Estes são escritos em cartões e a equipa
de desenvolvimento divide-os em \textbf{tarefas de implementação}.
Estas tarefas são a base das estimativas de custo e de schedule.

\vspace{2mm}

O cliente escolhe as \textbf{stories para inclusão} na próxima release
baseado em prioridade e estimativa de schedule.

\vspace{2mm}

Exemplo slide 24 e 25.

\pagebreak

\subsubsection{Templates de User Stories}

\begin{center}
  As a \textbf{(user)}, I \textbf{(want to)}, \textbf{(so that)}.
\end{center}

\begin{itemize}
  \item \textbf{User:} Refere o user final do software;
  \item \textbf{Want to:} Refere à intenção do user, e não
  à feature que este utiliza. Temos de especificar aquilo que
  o user quer alcançar com a tarefa, sem mencionar a UI da aplicação;

  \item \textbf{So that:} Descreve a "bigger picture". Qual é o objetivo
  do user? O que é que ele quer alcançar com esta feature?
\end{itemize}


\begin{flushleft}
  \textbf{Exemplo:} As a \uline{manager}, I want to be able to
  \uline{understand my colleagues progress} so that I can
  \uline{report our success and failures}.
\end{flushleft}

\subsubsection{Organização de User Stories}

\begin{itemize}
  \item \textbf{Role-Goal-Benefit:} Força o cliente a realmente pensar
  quem é que vai beneficiar de uma feature, o que é que eles querem
  alcançar e porque é que eles querem alcançar isso;

  \item \textbf{Limites/Needs:} Subconjunto de situações que são de interesse para esta feature;
  \item \textbf{Definição de Done:} Como validar uma feature e saber que esta está concluida?
  \item \textbf{Tarefas de Engenharia:} Como esta feature interaje com outras features
  dentro do sistema ou outros subsistemas;
  \item \textbf{Estimativa de esforço:} Fornece uma medida concreta sobre o valor de uma feature;
\end{itemize}

\subsubsection{Refatoração}

Conhecimento convencional em engenharia de software é \textbf{design for change}.
Compensa gastar tempo e esforçarmo-nos a anticipar mudanças, uma vez que,
reduz o cussto mais à frente no ciclo de vida.

\vspace{2mm}

No entanto, XP mantém que este principio não compensa, uma vez que,
mudanças não podem ser previstas. Em vez disso, propõe
\textbf{melhorias contantes do código} (refactoring) para tornar
mudanças mais fáceis quando têm de ser implementadas.

\vspace{2mm}

Equipas de programação procuram por possíveis \textbf{melhorias de software}
e fazem-nas mesmo que não sejam necessárias naquele momento.
Isto melhora a \textbf{compreensão do software} e desta maneira reduz
a necessidade de documentação.

\vspace{2mm}

Mudanças são \textbf{fáceis de fazer} uma vez que o código é
\textbf{bem estruturado} e \textbf{claro}. No entanto, algumas mudanças
requerem \uline{architecture refactoring}, o que é muito mais caro.

\subsubsection*{Exemplo}

\begin{itemize}
  \item \textbf{Re-organização} de uma classe hierárquica para remover duplicação de código;
  \item \textbf{Renomear} atributos e métodos de modo a serem mais faceis de entender;
  \item \textbf{Trocar inline code} com chamadas de métodos que estão incluidas em bibliotecas;
\end{itemize}

\pagebreak

\subsubsection{Desenvolvimento Test-First}

Testar é uma parte central em XP. O \textbf{desenvolvimento test-first}:
\begin{itemize}
  \item Teste incremental é desenvolvido a partir de cenários;
  \item Envolvimento de users no desenvolvimento de testes e validação;
  \item Correr todos os testes de componente de cada vez que uma nova versão
  é built.
\end{itemize}

\begin{center}
  \includegraphics[scale=0.5]{25}
\end{center}

\subsubsection{Automação de Testes}

Testes são escritos como \textbf{componentes executáveis} antes da
tarefa ser implementada. Estes devem:
\begin{itemize}
  \item Ser autonomos (stand-alone);
  \item Simular a submissão de input para ser testado;
  \item Verificar que o resultado é o esperado;
\end{itemize}

Uma \textbf{automated test framework} (ex: Junit) torna mais fácil
de escrever e executar testes.

\vspace{2mm}

Uma vez que os testes são automáticos, existe um conjunto de testes
que podem ser rapidamente e facilmente executados. Quando uma nova
funcionalidade é adicionada ao sistema, todos os testes podem ser executados
e identificar problemas no novo código imediatamente.

\subsubsection{Problemas com o desenvolvimento Test-First}

\begin{itemize}
  \item Os programadores preferem programar em vez de escrever testes,
  pelo que, por vezes estes fazem \textbf{short cuts ao escrever testes}.
  Como pro exemplo, testes incompletos que não testam todas as possibilidades.

  \item Alguns testes são \textbf{muito difíceis de escrever incrementalmente}.
  Como testes para uma UI complexa, é difícil escrever testes com display logic.

  \item É dificil de julgar a \textbf{cobertura} de um conjunto de testes.
  Podemos ter muitos testes de sistema e não cobrir tudo.
\end{itemize}

\pagebreak

\subsubsection{Programação em Pares (Pair Programming)}

Um parte programadores a trabalharem juntos para desenvolver código.
Os programadores sentam se juntos num mesmo computador para desenvolver
software. Serve como uma forma de \textbf{revisão de código informal}
uma vez que cada linha de código é olhada por mais do que uma pessoa.

\vspace{2mm}

Isto ajuda a desenvolver \uline{common ownership} do código e
\uline{compreensão coletiva} pela equipa.
Reduz o risco quando um programador deixa a equipa.

\vspace{2mm}

Em pair programming, os pares são criados dinamicamente
para que todos os membros da equipa trabalhem uns com os outros durante
o processo de desenvolvimento. Encoraja a refatorização, uma vez que,
toda a equipa pode benificiar com a melhoria do código do sistema.

\vspace{2mm}

Pair programming não é necessariamente ineficiente. Estudos mostram
que um par ao trabalhar junto é mais eficiente do que dois programadores
a trabalhar separadamente.

\subsection{Gestão de Projeto Agile}

A principar responsabilidade da gestão de projeto de software é
\textbf{gerir o projeto}, para que o software \uline{seja entregue a tempo}
e dentro do \uline{budget} planeada para o projeto.

\vspace{2mm}

A abordagem tradicional para a gestão de projeto é \textbf{plan-driven}.
Define \uline{o que} deve ser entregue, \uline{quando} deve ser entregue e \uline{quem}
vai trabalhar em cada entrega.

\vspace{2mm}

A gestão de projeto Agile requer uma abordagem diferente.
É adaptada de um \textbf{desenvolvimento incremental} e as \textbf{praticas
usadas em métodos agile}.

\subsubsection{Scrum}

É um \textbf{método agile} que foca na gestão incremental do desenvolvimento.

\vspace{2mm}

Existem três fases no Scrum:
\begin{itemize}
  \item A fase inicial é o \textbf{outline planning} onde tem de se estabelecer
  os objetivos gerais para o projeto e fazer o design da arquitetura
  de software.

  \item Isto é seguido por uma serie de \textbf{ciclos sprint}, onde cada
  ciclo desenvolve um incremento do sistema.

  \item A fase de \textbf{encerramento do projeto}, termina o projeto,
  completa a documentação necessária como ajudas nos frames e manual do
  utilizador e acessa aquilo que foi aprendido com o projeto.
\end{itemize}

\begin{center}
  \includegraphics[scale=0.45]{26}
\end{center}

\pagebreak

\subsubsection{Scrum - Terminologia}

\begin{center}
  \includegraphics[scale=0.45]{27}
  \includegraphics[scale=0.45]{28}
\end{center}

\subsubsection{Scrum sprint cycle}

\begin{center}
  \includegraphics[scale=0.5]{29}
\end{center}

O ponto inicial ara o planeamento é o \textbf{product backlog}.
É uma lista do trabalho a ser feito no projeto.

\vspace{2mm}

A \textbf{fase selecionada} envolve toda a equipa. Quem trabalha com o
cliente para selecionar as features e as funcionalidades do
\textbf{product backlog} que vão ser desenvolvidas durante o sprint.

\vspace{2mm}

Durante a \textbf{fase de desenvolvimento}, a equipa está isolada do
cliente e da organização. Todos os canais de comunicação passam pelo
"\textbf{Scrum master}".

\vspace{2mm}

No \textbf{final do sprint}, o trabalho realizado é revisto e apresentado aos
stakeholders.

\subsubsection{Teamwork in Scrum}

O papel do \textbf{Scrum master} é proteger o a equipa de desenvolvimento
de distrações externas.
\begin{itemize}
  \item Realiza reuniões diárias;
  \item Vai verificando o backlog para ver o trabalho a ser feito;
  \item Toma decisões;
  \item Mede o progresso usando o backlog;
  \item Comunica cocm os clientes e a gestão fora da equipa;
\end{itemize}

A equipa vai a reuniões diárias curtas (\textbf{Scrums})
\begin{itemize}
  \item Membros partilham informação, descrevem o progresso/problemas
  desde a última reunião, e aquilo que estava planeado para o dia;

  \item Isto significa que todos na equipa sabem aquilo que se passa,
  os porblemas que surgiram, podem re-planear num curto tempo o trabalho;
\end{itemize}

\subsubsection{Scrum - Benefícios}

\begin{itemize}
  \item O produto é repartido num conjunto de pedaços \textbf{geriveis}. e \textbf{faceis de compreender}.
  \item \textbf{Requisitos instáveis} não prrendem o progresso;
  \item Toda a equipa tem visibilidade de tudo, consequentemente, a comunicação da equipa melhora;
  \item Os clientes vêm as entregas on-time dos incrementos, ganhando feedback em como o produto funciona;
  \item Confiança entre a equipa e o cliente, todos esperam que o projeto tenha sucesso;
\end{itemize}

\subsubsection{Kanban}

É um sistema ágil que pode ser usado para melhorar qualquer desenvolvimento
de software incluindo Scrum, XP ou Waterfall.

\vspace{2mm}

O nome "Kanban" vem do Japonês e significa "signboard" ou "billboard".
Foi usado pela primeira vez pela Toyota para Just-in-time manufacturing
plants, com o objetivo de limitar o trabalho em progresso (WIP - work in progress).

\subsubsection{Scrum vs Kanban}

Em \textbf{Scrum}, tu escolhes o trabalho que vais fazer durante o
próximo sprint antes deste começar. Depois, damos \uline{lock}
ao sprint, fazemos o trabalho todo, e passado algumas semanas
(duração normal para um sprint), a queue fica vazia.

\begin{center}
  \includegraphics[scale=0.48]{30}
\end{center}

Em \textbf{Kanban}, tudo o que é limitado é o tamanho das queues,
chamado de \textbf{work in progress (WIP) limits}. Podemos alterar
os items na queue a qualquer momento, não existindo
um "fim de sprint". O trabalho continua a fluir.  

\begin{center}
  \includegraphics[scale=0.48]{31}
\end{center}


\pagebreak

\begin{center}
  \includegraphics[scale=0.4]{32}
\end{center}

\subsection{Scaling Agile Methods}

Métodos Agile provaram ser muito eficazes para projetos
pequenos/médios, que podem ser desenvolvidos por uma equipa
pequena co-localizada.
Escalar métodos Agile involve mudar estes para poderem ser
utilizados em projetos cada vez maiores, onde existem múltiplas
equipas de desenvolvimento, podendo trabalhar até mesmo em diferentes
locais.

\vspace{2mm}

Quando escalamos métodos Agile, é importante manter fundamentos
Agile: Planeamento flexivel, releases de sistema frequentes,
integração contínua, desenvolvimento test-driven e boa comunicação
entre a equipa.

\subsubsection{Problemas de Sistema}

\begin{itemize}
  \item Quão grande é o sistema a ser desenvolvido? Métodos Agile
  \uline{são mais eficientes em equipas pequenas e co-localizadas}, em que
  ocorre uma comunicação informal.

  \item Que tipo de sistema está a ser desenvolvido? Sistemas que necessitem
  de \textbf{muita análise antes da implementação} precisam de um
  design (mais) detalhado.

  \item Qual é o tempo de vida esperado do sistema?
  \textbf{Sistemas de longa duração necessitam de documentação} para comunicar
  as intenções do sistema com os developers da equipa de suporte.

  \item O sistema está sujeito a regulamentos externos?
  Se o sistema é regulado, muito provavelmente, é necessário
  \textbf{produzir documentação detalhada} como parte do caso de segurança do
  sistema.
\end{itemize}

\subsubsection{Desenvolvimento de Sistemas Grandes}

Sistemas grandes são normalmente coleções de sistemas de comunicação separados,
onde \textbf{equipas separadas} desenvolvem cada sistema. Frequentemente,
estas equipas trabalham em locais diferentes, por vezes até em zonas com diferentes fusos horários.

\vspace{2mm}

Sistemas grandes são "\textbf{brownfield systems}" isto é,
incluem e interagem com vários sistemas existentes.
Muitos dos requisitos do sistema estão relacionados com a interação, logo
não se rendem muito à flexibilidade e desenvolvimento incremental.

\pagebreak

Sistemas grandes e os seus processos de desenvolvimento são
muitas vezes restritos por \textbf{regras e regulamentos externos},
limitando a forma como podem ser desenvolvidos.

\vspace{2mm}

Sistemas grandes tem uma \textbf{aquisição longa} e
um tempo de desenvolvimento longo também. É dificil de manter equipas
coerentes que sabem sobre o sistema durante esse periodo, uma vez que,
eventualmente, os membros vão para outros projetos ou trabalhos.

\vspace{2mm}

Sistemas grandes normalmente tem um conjunto diverso de
\textbf{stakeholders}. É praticamente impossível involver todos estes
stakeholders no processo desenvolvido.

\subsubsection{Agile: Scaling up em sistemas grandes}

\begin{itemize}
  \item Uma \uline{abordagem completamente incrementeal aos requisitos de engenharia} é \textbf{impossível};
  \item \textbf{Não pode existir} um único \uline{product owner};
  \item \textbf{Não é possível} \uline{focar apenas no código};
  \item \uline{Mecanismos de comunicação cross-team} têm de ser \textbf{designed} e \textbf{utilizados};
  \item \uline{Integração continua} é praticamente \textbf{impossível}, no entanto, é essencial
  manter builds frequentes do sistema e regular releases do sistems;
\end{itemize}

\subsubsection{Multi-team Scrum}

\begin{itemize}
  \item \textbf{Role replication}: Cada equipa tem um Product Owner para o
  seu trabalho e Scrum Master.

  \item \textbf{Product architects}: Cada equipa escolhe um arquiteto
  do produto que colaboram para desenhar e evoluir toda a arquitetura
  do sistema.

  \item \textbf{Release alignment}: As datas de releases de produtos
  de cada equipa são alinhadas de modo a demonstrar que um sistema
  completo está produzido.

  \item \textbf{Scrum of scrums}: Existe um Scrum of scrums diário, onde
  os representantes de cada equipa se encontram para discutir o progresso
  e o plano de trabalho a ser concluído.
\end{itemize}

\pagebreak

\section{DevOps}

\subsection{Metodologia Agile}

\begin{itemize}
  \item Cada projeto é dividido em várias iterações;
  \item Todas as iterações devem ter a mesma duração (2-8 semanas);
  \item No final de cada iteração, um produto funcional deve ser entregue;
\end{itemize}

\begin{center}
  \includegraphics[scale=0.45]{33}
\end{center}

\subsection{Quais são as limitações de Agile?}

Enquanto que a parte de Desenvolvimento é continua,
a parte de Operações não é.

\begin{center}
  \includegraphics[scale=0.6]{34}
\end{center}


\subsection{Dev vs Ops}

A equipa de \textbf{desenvolvimento} começa a trabalhar no projeto,
"atirando" uma realease de software "por cima da parede" para as
Operações.

\vspace{1mm}

As \textbf{Operações} pegam nos artefactos da release e começam
a preparar o seu desenvolvimento. Estes também  editam os ficheiros
de configuração para refletir o ambiente de produção
(que é \textbf{bastante diferente dos ambientes de Desenvolvimento}).

\pagebreak

Em caso de falha\dots
\begin{itemize}
  \item Os Developers são chamados para resolver o problema;
  \item \textbf{Operações} afirma que \uline{O Desenvolvimento
  deu código defeituoso};
  \item \textbf{Desenvolvimento} responde apontando o facto de que
  \uline{funcionava perfeitamente nos seus ambientes}
  (logo o problema é das Operações, que fizeram algo de errado).
  \item Os Developers estão a ter dificuldades em sequer perceber o problema.
  Devido à configuração, localização dos ficheiros, ao procedimento utilizado
  para chegar a esse estado é diferente do esperado.
\end{itemize}

\begin{center}
  \textbf{Qual é a Solução?}
\end{center}

\subsection{DevOps}

DevOps é sobre a remoção das barreiras entre duas equipas
tradicionalmente isoladas: \textbf{Desenvolvimento} e \textbf{Operações}.

\vspace{2mm}

Em algumas organizações, pode nem haver uma equipa separada,
\textbf{os engenheiros fazem ambos}.

\vspace{2mm}

As \textbf{duas equipas trabalham juntas} de modo a otimizar
tanto a produtividade dos desenvolvedores e a fiabilidade
das operações.
Estas \textbf{comunicam frequentemente} aumentando a eficiência
e a qualidade dos serviços que fornecem aos clientes.

Têm um \textbf{ownership completo para os seus serviços}, pensando
nas necessidades dos clientes finais e como podem contribuir para
resolver essas necessidades.

\vspace{2mm}

As equipas vêm o ciclo completo de desenvolvimento e infrastruturas
como parte das suas responsabilidades.

\begin{center}
  \includegraphics[scale=0.6]{35}
\end{center}

\pagebreak

\begin{itemize}
  \item \textbf{Desenvolvimento} Agile. Gestão do código fonte
  (Plan, Code, Build). Manutenção de diferentes versões do código;
  \item \textbf{Integração} Contínua (Integrate, Test).
  Compilar, revisão de código, testes unitários, testes de integração;
  \item \textbf{Entrega} Contínua (Release). Deploy da aplicação (build), realizando
  testes de aceitação nos users;
  \item \textbf{Desenvolvimento} Contínuo (Deploy, Operate). Deploy na
  aplicação testada/aceite;
  \item \textbf{Monitorização} Contínua;
\end{itemize}

\subsubsection{DevOps - Ciclo de Vida}

\begin{center}
  \includegraphics[scale=0.55]{36}
\end{center}

\subsubsection{DevOps - Como implementar?}

\begin{center}
  \includegraphics[scale=0.55]{37}
\end{center}

\pagebreak

\subsection{Um asset chave: Infrastrutura como Código (IaC)}

\textbf{a.k.a. Programmable Infrastructure} ou \textbf{software-defined
infrastructure}
\begin{itemize}
  \item A infrastrutura é decrita por código e pode ser trackeada,
  validada, e reconfigurada de forma automática;
  \item Engenheiros DevOps podem interagir com a infraestrutura utilizando
  ferramentas code-based e \textbf{tratando a infrastrutura de uma
  forma semelhante a como tratam o código da aplicação};
\end{itemize}

\vspace{2mm}

Gestão de configuração
\begin{itemize}
  \item Developers e administradores de sistemas usam código para
  \uline{automar sistemas operativos} e \uline{configurar hosts},
  \uline{tarefas operacionais}, e mais;
  \item A utilização de código faz com que as mudanças na configuração
  sejam \uline{repetíveis} e \uline{padronizadas};
\end{itemize}

\subsection{Integração Contínua (CI)}

\subsubsection{Ideia base de CI}

A continua integração é um processo onde o código é
verificado para um repositório frequentemente.

\begin{center}
  \includegraphics[scale=0.55]{38}
\end{center}

\pagebreak

\subsubsection{Poruque é que CI é crucial para DevOps?}

\begin{flushleft}
  \textbf{Erros são encontrados mais cedo:}
  \begin{itemize}
    \item Se existe um erro na cópia local ou no código,
    uma falha na build vai ocorrer no "estado apropriado";
    \item Força o desenvolvedor a corrigir o bug antes de
    proceder. Equipas QA (Quality Assurance) vão também beneficiar
    disto, uma vez que estas vão trabalhar mais frequentemente em builds estáveis;
  \end{itemize}

  \textbf{Definir o estágio para CI/CD:}
  \begin{itemize}
    \item CI reduz interveenção manual, uma vez que a build,
    sanidade e outros testes são supostamente executados automaticamente;
    \item Isto permite uma entrega continua de sucesso
  \end{itemize}

  \textbf{Confidencialidade do Projeto}
\end{flushleft}

\subsubsection{Getting Started with CI}

\begin{itemize}
  \item \textbf{Build Script} (ex: Maven, Gradle, Ant, Make, \dots),
  é um script, ou um conjunto de scripts, usados para compilar, testar,
  inspecionar e dar deploy a um software;

  \item \textbf{Version Control System} (ex: Git, GitHub, GitLab, \dots),
  permite guardar todas as mudanças feitas a um ficheiro ou conjunto
  de ficheiros ao longo do tempo, de modo a que seja possível
  aceder a versões específicas mais tarde;

  \item \textbf{CI Server} (ex: Jenkins, Travis CI, Hudson, \dots),
  é um servidor que corre uma build de integração quando uma mudança
  é commited num repositório de controlo de versões. Apesar de ser recomendado
  correr uma build a cada mudança, buikds podem ser agendadas
  (ex: nightly builds);

  \item \textbf{Automation testing framework} (ex: Selenium, Appium,
  TestComplete, \dots);
\end{itemize}

\subsubsection{Build Script com Maven}

\vspace{2mm}

\begin{center}
  \includegraphics[scale=0.55]{39}
\end{center}

\pagebreak

\subsubsection{CI Server com Jenkins}

O \textbf{código é built} e testado quando um desenvolvedor
faz um commit. Se o build for bem sucedida,
\textbf{Jenkins faz deploy} da fonte para um servidor de testes
e notifica a equipa de deployment.
Se a build falhar, então o Jenkins vai notificar os erros
à equipa de desenvolvimento.

\begin{center}
  \includegraphics[scale=0.55]{40}
\end{center}

\subsubsection{CI - Best Practices}

\begin{flushleft}
  \textbf{Versioning}
  \begin{itemize}
    \item Repositório partilhado para manter o código. Todos os
    ficheiros donte são commited para o repositório;
    \item Merge diário. As mudanças são commited para a mainline, diariamente;
    \item Short-lived branches. É assim que devem ser, idealmente menos de uns dias
    e nunca mais do que uma iteração;
  \end{itemize}

  \textbf{Build Configuration}
  \begin{itemize}
    \item Build independente. Escrever build scripts desacopolados de IDEs. Estes são executados pelo
    sistema CI para que o software possa ser built a cada mudança;
    \item Build em cada mudança. Building e testar software a cada mudança commited;
    \item Limite de build. Falhar uma build quando uma regra do projeto é violada (ex: testes lentos);
  \end{itemize}

  \pagebreak

  \textbf{Team Policy}
  \begin{itemize}
    \item Stop the line (build quebrada). Corrigir erros de entrega de software mal estes aconteçam;
    \item Fazer commits regularmente. Cada membro da equipa deve verificar o "trunk", pelo menos uma vez por dia;
    \item Feedback continuo. Enviar feedback automaticamente do sistema CI
    para os membros da Cross-functional team;
    \item Falhas rápidas. Falhar a build o mais rápido possível;
    \item Builds rápidas. Uma build fornece feedback em problemas
    comuns o mais rápido possível (normalmente menos de 10 minutos);
  \end{itemize}
\end{flushleft}

\subsection{Entrega Contínua (CD)}

A Engenharia de Software é baseada em \textbf{CI}. CI
foca nas equipas de desenvolvimento, em que o output é o
input do porcesso de testes manuais e o resto do processo
de realease.

Muito tempo pode ser "perdido" desta forma através de testes
e operações (ex: testers esperam por "boas" builds de software
equipas de operações esperam por documentação e fixes).

\vspace{2mm}

\textbf{CD} previne isto, as relações entre stakeholders
involvidos na entrega é mais proxima e colaborativa (cultura DevOps).

Automação extensiva a todas as partes do processo de entrega,
CD pipeline.

\subsubsection{CD Pipeline}

\begin{center}
  \includegraphics[scale=0.55]{41}
\end{center}

\begin{center}
  \textbf{Vermelhos}: Fase de CI;
  \textbf{Azuis}: Fase pós CI;
  \textbf{Verdes}: Fase de CD;
\end{center}

\pagebreak

\subsubsection*{Fase pós CI}

Consiste de múltiplos ambientes/estágios com o objetivo de testar.
Inclui testes \textbf{manuais e automaticos}.

Alguns estágios podem ser executados em paralelo (ex: user
acceptance testing (UAT) e performance testing em sistemas de backend).

Estágios podem ser automaticamente executados quando o anterior
termina ou é manualmente aprovado (ex: clicar um botão).

\subsubsection*{Fase de CD}

Novas versões estão disponíveis para os clientes.
Existem várias estratégias e práticas para fazer isto:
\begin{itemize}
  \item eat your own dog food;
  \item canary releases;
  \item dark launches;
  \item gradual rollouts;
  \item A/B testing;
  \item blue/green deployments;
\end{itemize}

\subsubsection{Eat your own dog food}

\begin{flushleft}
  \textbf{Ideia:} Os empregados utilizam a versão mais recente internamente.
  Se tudo estiver como esperado, então a versão é lançada para os clientes.

  \vspace{2mm}

  "A companhia usa o seu próprio produto para testar e promover o produto".
\end{flushleft}

\subsubsection{Canary Releases}

\begin{flushleft}
  \textbf{Ideia:} Lançar uma nova versão para um subconjunto de utilizadores
  primeiro, enquando o resto interage com a versão antiga estável.
  Em cado de problemas com esta nova versão, \uline{apenas um pequeno
  número de utilizadores é afetado}, logo o impacto do problema é reduzido. 

  \vspace{2mm}

  Canário é comparado à versão existente em termos do
  conjunto dos critérios como estabilidade, performance, ou correção.
  Os utilizadores são escolhidos com base na sua localização,
  role (ex: admin, early, stable, \dots) e de forma aleatória
  (ex: 1\% dos utilizadores).
\end{flushleft}

\subsubsection{Dark Launches}

\begin{flushleft}
  \textbf{Ideia:} Mitigar problemas de performance e de reliability
  de novas funcionalidades ao enfrentar carga semelhante à de produção,
  através de um lançamento em produção, \uline{sem ser visivel para os utilizadores}.

  \vspace{2mm}

  Dark launches são normalmente released para um \uline{grupo de
  utilizadores que não sabem que estão a ser testados}. A nova funcionalidade
  não lhes é indicada de qualquer maneira.

  Dev teams podem identificar e corrigir os erros restantes.
  Preocupações de escalabilidade antes de habilitar a funcionalidade para os utilizadores.
\end{flushleft}

\pagebreak

\subsubsection{Gradual Rollouts}

\begin{flushleft}
  \textbf{Ideia:} \uline{Aumentar o número de users escolhidos}
  para a nova versão de uma forma gradual, até substituir completamente
  a versão antiga.

  Mostra se a nova versão pode lidar com
  aumentando a carga e se escala corretamente.

  \vspace{2mm}

  Muitas das vezes é combinada com \textbf{canary releases} e
  \textbf{dark launches}.
\end{flushleft}

\begin{center}
  \includegraphics[scale=0.4]{42}
\end{center}

\subsubsection{A/B Testing}

\begin{flushleft}
  \textbf{Ideia:} Comparar \uline{duas versões de software}
  uma à outra, normalmente apenas diferencia num aspeto
  testado, para determinar o efeito de uma dada mudança
  \begin{itemize}
    \item forma estatistica de testar hipoteses, pelo que
    requerem amostras grandes o suficiente para ter "poder estatistico";
    \item maioritariamente usado no UI para testar varios layouts ou
    designs;
  \end{itemize}
\end{flushleft}

\begin{center}
  \includegraphics[scale=0.45]{43}
\end{center}

\subsubsection{Blue/Green Deployments}

\begin{flushleft}
  \textbf{Ideia:} ter dois ambientes de produção idênticos,
  um hospedando a versão atual do software (green), versão estável,
  a outra (blue) representa a nova versão.

  \begin{itemize}
    \item \uline{Release:} simplesmente mudar o roiter para que todo o tráfego
    seja direcionado para o ambiente blue (ou green) e utilizar o
    ambiente green (ou blue) para testar a nova versão;
    \item \uline{Vantagens:} em caso de problemas depois da release,
    um rápido rollback (switch) para a versão anterior é possível;
    \item \uline{Obstaculo:} As bases de dados fazem parte de ambos
    os ambientes, pelo que um switch requer uma migração de dados
    / sincronização da base de dados;
  \end{itemize}
\end{flushleft}

\begin{center}
  \includegraphics[scale=0.5]{44}
\end{center}

\pagebreak

\subsection{Beneficios de DevOps}

\begin{flushleft}
  \textbf{Velocidade}
  \begin{itemize}
    \item \textbf{Mover a elevada velocidade} de forma a inovar mais rápido
    para os clientes, adaptar as mudanças nos mercados de forma melhor, e
    crescer mais eficientemente em obter resultados de negócio;
    \item Por exemplo, CD deixam as equipas ter ownership
    dos serviços e depois dar release a updates para ser mais rápido;
  \end{itemize}

  \textbf{Fiabilidade}
  \begin{itemize}
    \item Garante a \textbf{qualidade dos updates da aplicação}
    e as mudanças de infrastrutura para poder entregar fiavelmente
    a um ritmo mais rápido, enquanto se mantém uma experiência
    positiva para o cliente;
    \item Usar práticas como \uline{CI e CD para testar cada alteração
    é funcional e seguro};
  \end{itemize}

  \textbf{Escala}
  \begin{itemize}
    \item Automação e consistência \textbf{ajudam a gerir sistemas complexos
    ou com mudanças frequentes} eficientemente e com risco reduzido;
    \item Por exemplo, \uline{infrastruturas como código} ajuda a gerir
    o desenvolvimento, testar, e ambientes de produção de forma
    repetivel e mais eficiente;
  \end{itemize}

  \textbf{Melhora a colaboração}
  \begin{itemize}
    \item \textbf{As equipas de Dev e Ops} colaboram,
    partilham muitos responsabilidades e combinam os seus workflows;
    \item Isto reduz ineficiências e salva tempo, escrevendo código,
    e a reduz a passagem de informação entre equipas;
  \end{itemize}

  \textbf{Segurança}
  \item Mover rapidamente enquando mantém o controlo e preserva a conformidade;
  \item Um pode adotar o modelo DevOps sem sacrificar a segurança através de
  \textbf{politicas automaticas de compliance}, controlos fine-grained e
  configuração de técnicas de gestão;
  \item Por exemplo, usar infrastruturas como código (e politica como
  código), podemos definir e depois rastrear a conformidade em escala;
\end{flushleft}

\pagebreak

\subsection{DevOps - CALMS}

DevOps não é puramente técnico, também inclui aspetos sumarizados
pelo acrónimo \textbf{CALMS}:

\begin{center}
  \includegraphics[scale=0.6]{45}
\end{center}

\end{document}